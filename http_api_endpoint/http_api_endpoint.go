//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This program is an HTTP Server used to test Docker Logging Plugins that send data to an API Endpoint.
//
// The intent of this program is for those Docker Logging Plugins that do not support the read log api such as:
//
//   Sumologic Docker Logging Plugin
//
// You run this HTTP Server and configure the Docker Logging Plugin to send it's logs to it.
//
// The data can be retrieved via curl get
//
// Syntax: ./http_api_endpoint [options]
//
//   --port    (The port for the http_api_endpoint HTTP Server to listen on. Defaults to port 80)
//   --debug   (write debugging information)
//   --help    (display help)
//
// To Test:
//
//   Issue the following curl command to send new data to the http_api_endpoint:
//      curl -s -X POST -d "${DATA}" http://127.0.0.1:80
//
//      Note: if any data was previously sent, it will be replaced.
//
//   Issue the following curl command to send data to the http_api_endpoint and append to the already collected data:
//      curl -s -X PUT -d "${DATA}" http://127.0.0.1:80
//
//   Issue the following curl command to retrieve the data from the http_api_endpoint:
//      curl -s -X GET http://127.0.0.1:80
//
//   Issue the following curl command to erase any data currently collected by the http_api_endpoint:
//      curl -s -X DELETE http://127.0.0.1:80
//
// To Terminate:
//
//    curl http://127.0.0.1:80/EXIT
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gary Forghetti
// Docker, Inc
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
)

var allLoggedData string
var debugMode bool

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Log the data sent to this HTTP API Endpoint
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func logData(req *http.Request) {
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		log.Fatal(err)
	}

	if len(body) > 0 {
		data := string(body)
		if debugMode {
			log.Println(data)
		}
		if req.Method == `POST` {
			allLoggedData = data
		} else if req.Method == `PUT` {
			allLoggedData += data
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Process the HTTP Request
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func processRequest(rw http.ResponseWriter, req *http.Request) {
	if debugMode {
		log.Println(fmt.Sprintf(`%s request received`, req.Method))
	}
	switch req.Method {
	case `GET`:
		fmt.Fprintf(rw, allLoggedData)
	case `POST`:
		logData(req)
	case `PUT`:
		logData(req)
	case `DELETE`:
		allLoggedData = ``
	default:
		fmt.Fprintf(rw, `I don't recognize the request!`)
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Display the Command Help
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func usage() {
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr, `Runs a HTTP API Endpoint for testing a Docker Logging Plugin that sends data to an HTTP API endpoint`)
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr, `Syntax: http_api_endpoint [options]`)
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr, `Options:`)
	flag.PrintDefaults()
	fmt.Fprintln(os.Stderr)
}

func main() {
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Set the Log Flags to display the short file name and line number when Logging error messages using the log Package
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	log.SetFlags(log.LstdFlags | log.Lshortfile)

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Setup, parse and verify the command line options
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	httpPortPtr := flag.String(`port`, `80`, ` The http port for the http_api_endpoint to listen on.`)
	debugPtr := flag.Bool(`debug`, false, ` Enables debugging output.`)
	helpPtr := flag.Bool(`help`, false, ` Displays the command help.`)

	flag.Usage = usage
	flag.Parse()

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Display the command usage if the help command line option was specified
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if *helpPtr {
		usage()
		os.Exit(0)
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get the command line options
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	debugMode = *debugPtr

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Setup a HTTP handler for the base URL
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	http.HandleFunc(`/`, processRequest)

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Setup a HTTP Handler to check for /EXIT and exit the program
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	http.HandleFunc(`/EXIT`, func(rw http.ResponseWriter, req *http.Request) {
		fmt.Fprintf(rw, `Exiting.\n`)
		os.Exit(0)
	})

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Setup a HTTP Handler to check for /exit and exit the program
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	http.HandleFunc(`/exit`, func(rw http.ResponseWriter, req *http.Request) {
		fmt.Fprintf(rw, `Exiting.\n`)
		os.Exit(0)
	})

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Start the HTTP Server on the specified port
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if debugMode {
		log.Println(fmt.Sprintf(`Listening on port: %s`, *httpPortPtr))
	}

	log.Fatal(http.ListenAndServe(fmt.Sprintf(`:%s`, *httpPortPtr), nil))
}
